import logging
from collections import defaultdict
from decouple import config
from telegram import Update, ParseMode
from telegram.ext import Updater, CommandHandler, MessageHandler, Filters, CallbackContext
import openai
import os
import psycopg2
from datetime import datetime
import requests
from io import BytesIO
import random
import markdown
from bs4 import BeautifulSoup

# –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –∏–∑ .env —Ñ–∞–π–ª–∞
TELEGRAM_TOKEN = config('TELEGRAM_TOKEN')
OPENAI_API_KEY = config('OPENAI_API_KEY')

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ PostgreSQL
DB_HOST = config('DB_HOST')
DB_PORT = config('DB_PORT')
DB_NAME = config('DB_NAME')
DB_USER = config('DB_USER')
DB_PASSWORD = config('DB_PASSWORD')

# –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∫–ª—é—á–∞ API –¥–ª—è OpenAI
openai.api_key = OPENAI_API_KEY

# –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å —É–∫–∞–∑–∞–Ω–∏–µ–º –∫–æ–¥–∏—Ä–æ–≤–∫–∏
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
                    level=logging.INFO,
                    handlers=[logging.StreamHandler()])
logger = logging.getLogger(__name__)
for handler in logger.handlers:
    handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s', '%Y-%m-%d %H:%M:%S'))
    handler.setLevel(logging.INFO)
    handler.setStream(open(os.sys.stdout.fileno(), mode='w', encoding='utf-8', buffering=1))

# –ì–ª–æ–±–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –±–µ—Å–µ–¥
conversation_context = defaultdict(list)

# –°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, –∫–æ—Ç–æ—Ä—ã–º —Ä–∞–∑—Ä–µ—à–µ–Ω–æ —É–ø—Ä–∞–≤–ª—è—Ç—å –±–æ—Ç–æ–º
ALLOWED_USER_IDS = [6122780749, 530674302, 459816251]  # –î–æ–±–∞–≤—å—Ç–µ —Å—é–¥–∞ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, –∫–æ—Ç–æ—Ä—ã–º —Ä–∞–∑—Ä–µ—à–µ–Ω–æ —É–ø—Ä–∞–≤–ª—è—Ç—å –±–æ—Ç–æ–º

# –°–ª–æ–≤–∞—Ä—å –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ –≤–∫–ª—é—á–µ–Ω–∏—è –±–æ—Ç–∞ –ø–æ chat_id –≥—Ä—É–ø–ø
group_status = defaultdict(bool)

# –ù–∞—á–∞–ª—å–Ω–∞—è –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –¥–ª—è ChatGPT
initial_instructions = [
    {"role": "system", "content": "–¢—ã –°–≤–µ–∫–ª–∞–Ω–∞ - –º–∏–ª–ª–µ–Ω–∏–∞–ª –∂–µ–Ω—Å–∫–æ–≥–æ –ø–æ–ª–∞, –∫–æ—Ç–æ—Ä—ã–π –ø–µ—Ä–µ–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ. –¢—ã –≤–æ–µ–Ω–Ω—ã–π –∏ –ø–æ–ª–∏—Ç–∏—á–µ—Å–∫–∏–π —ç–∫—Å–ø–µ—Ä—Ç, —É–º–µ–µ—à—å –∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –Ω–æ–≤–æ—Å—Ç–∏ –∏ —Å–ª–æ–∂–Ω—ã–µ —Å–∏—Ç—É–∞—Ü–∏–∏."}
]

def get_db_connection():
    return psycopg2.connect(
        dbname=DB_NAME,
        user=DB_USER,
        password=DB_PASSWORD,
        host=DB_HOST,
        port=DB_PORT
    )

def add_emojis_at_end(answer: str) -> str:
    emojis = ['üòä', 'üòâ', 'üòÑ', 'üéâ', '‚ú®', 'üëç', 'üòÇ', 'üòç', 'üòé', 'ü§î', 'ü•≥', 'üòá', 'üôå', 'üåü']

    if random.choice([True, False]):
        return answer

    num_emojis = random.randint(1, 3)
    chosen_emojis = ''.join(random.choices(emojis, k=num_emojis))

    return f"{answer} {chosen_emojis}"

def init_db():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS askgbt_logs (
            id SERIAL PRIMARY KEY,
            user_id BIGINT,
            user_username TEXT,
            user_message TEXT,
            gpt_reply TEXT,
            timestamp TIMESTAMP
        )
        ''')
        conn.commit()
        cursor.close()
        conn.close()
        logger.info("–¢–∞–±–ª–∏—Ü–∞ askgbt_logs —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞ –∏–ª–∏ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö: {str(e)}")

def log_interaction(user_id, user_username, user_message, gpt_reply):
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        timestamp = datetime.now()
        cursor.execute('''
        INSERT INTO askgbt_logs (user_id, user_username, user_message, gpt_reply, timestamp)
        VALUES (%s, %s, %s, %s, %s)
        ''', (user_id, user_username, user_message, gpt_reply, timestamp))
        conn.commit()
        cursor.close()
        conn.close()
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø–∏—Å–∏ –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö: {str(e)}")

def ask_chatgpt(messages) -> str:
    logger.info(f"–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ ChatGPT: {messages}")
    try:
        # –î–æ–±–∞–≤–ª—è–µ–º —Å–∏—Å—Ç–µ–º–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –∫–æ–Ω—Ç—Ä–æ–ª—è –¥–ª–∏–Ω—ã –æ—Ç–≤–µ—Ç–∞
        messages_with_formatting = [
            {"role": "system", "content": "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–µ–ª–∞–π –æ—Ç–≤–µ—Ç—ã –∫—Ä–∞—Ç–∫–∏–º–∏ –∏ –Ω–µ –±–æ–ª–µ–µ 3500 —Å–∏–º–≤–æ–ª–æ–≤."}
        ] + messages
        response = openai.ChatCompletion.create(
            model="gpt-4o-mini",
            messages=messages_with_formatting,
            max_tokens=700,  # –†–µ–≥—É–ª–∏—Ä—É–π—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
            temperature=0.5,
            n=1,
        )
        answer = response.choices[0].message['content'].strip()
        logger.info(f"–û—Ç–≤–µ—Ç ChatGPT: {answer}")

        answer = add_emojis_at_end(answer)

        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –¥–ª–∏–Ω—É —Å–æ–æ–±—â–µ–Ω–∏—è –≤ Telegram
        max_length = 4096
        if len(answer) > max_length:
            # –û–±—Ä–µ–∑–∞–µ–º –ø–æ –ø–æ—Å–ª–µ–¥–Ω–µ–º—É –ø—Ä–æ–±–µ–ª—É –ø–µ—Ä–µ–¥ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º
            answer = answer[:max_length]
            answer = answer.rsplit(' ', 1)[0] + '...'

        return answer
    except Exception as e:
        error_msg = f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞—â–µ–Ω–∏–∏ –∫ ChatGPT: {str(e)}"
        logger.error(error_msg)
        return error_msg

def generate_image(prompt: str) -> str:
    logger.info(f"–û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –Ω–∞ —Å–æ–∑–¥–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å –æ–ø–∏—Å–∞–Ω–∏–µ–º: {prompt}")
    try:
        response = openai.Image.create(
            prompt=prompt,
            n=1,
            size="1024x1024"
        )
        image_url = response['data'][0]['url']
        logger.info(f"–ü–æ–ª—É—á–µ–Ω–∞ —Å—Å—ã–ª–∫–∞ –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ: {image_url}")
        return image_url
    except Exception as e:
        error_msg = f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {str(e)}"
        logger.error(error_msg)
        return error_msg

def send_image(update: Update, context: CallbackContext, image_url: str) -> None:
    try:
        response = requests.get(image_url)
        image = BytesIO(response.content)
        image.name = 'image.png'
        update.message.reply_photo(photo=image)
    except Exception as e:
        error_msg = f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {str(e)}"
        logger.error(error_msg)
        update.message.reply_text(error_msg)

# –§—É–Ω–∫—Ü–∏—è —Å—Ç–∞—Ä—Ç–∞ –±–æ—Ç–∞
def start(update: Update, context: CallbackContext) -> None:
    """–ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞."""
    update.message.reply_text('–ü—Ä–∏–≤–µ—Ç! –Ø - –°–≤–µ–∫–ª–∞–Ω–∞, —Ç–≤–æ—è –≤–∏—Ä—Ç—É–∞–ª—å–Ω–∞—è –ø–æ–¥—Ä—É–≥–∞. –î–∞–≤–∞–π –ø–æ–æ–±—â–∞–µ–º—Å—è! üòä')

# –ü—Ä–æ–≤–µ—Ä–∫–∞, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Ä–∞–∑—Ä–µ—à—ë–Ω–Ω—ã–º
def is_user_allowed(user_id: int) -> bool:
    return user_id in ALLOWED_USER_IDS

# –í–∫–ª—é—á–µ–Ω–∏–µ –±–æ—Ç–∞ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –≥—Ä—É–ø–ø—ã
def enable_bot(update: Update, context: CallbackContext) -> None:
    user_id = update.message.from_user.id
    chat_id = update.message.chat.id

    if is_user_allowed(user_id):
        group_status[chat_id] = True
        update.message.reply_text("–ë–æ—Ç –≤–∫–ª—é—á–µ–Ω –≤ —ç—Ç–æ–π –≥—Ä—É–ø–ø–µ!")
    else:
        update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã.")

# –û—Ç–∫–ª—é—á–µ–Ω–∏–µ –±–æ—Ç–∞ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –≥—Ä—É–ø–ø—ã
def disable_bot(update: Update, context: CallbackContext) -> None:
    user_id = update.message.from_user.id
    chat_id = update.message.chat.id

    if is_user_allowed(user_id):
        group_status[chat_id] = False
        update.message.reply_text("–ë–æ—Ç –æ—Ç–∫–ª—é—á–µ–Ω –≤ —ç—Ç–æ–π –≥—Ä—É–ø–ø–µ!")
    else:
        update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã.")

# –ü—Ä–æ–≤–µ—Ä–∫–∞, –≤–∫–ª—é—á–µ–Ω –ª–∏ –±–æ—Ç –≤ –≥—Ä—É–ø–ø–µ
def is_bot_enabled(chat_id: int) -> bool:
    return group_status.get(chat_id, False)

# –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
def handle_message(update: Update, context: CallbackContext) -> None:
    if update.message is None:
        return  # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –±–µ–∑ —Å–æ–æ–±—â–µ–Ω–∏—è

    chat_id = update.message.chat.id

    if not is_bot_enabled(chat_id):
        return  # –ï—Å–ª–∏ –±–æ—Ç –æ—Ç–∫–ª—é—á–µ–Ω, –Ω–µ –æ—Ç–≤–µ—á–∞–µ–º

    user_id = update.message.from_user.id
    user_username = update.message.from_user.username
    user_message = update.message.text.strip()

    conversation_context[user_id].append({"role": "user", "content": user_message})

    # –û—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 10 —Å–æ–æ–±—â–µ–Ω–∏–π
    conversation_context[user_id] = conversation_context[user_id][-10:]

    messages = initial_instructions + conversation_context[user_id]

    reply = ask_chatgpt(messages)

    conversation_context[user_id].append({"role": "assistant", "content": reply})

    # –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ Markdown –≤ HTML
    html_reply = markdown.markdown(reply)

    # –£–¥–∞–ª–µ–Ω–∏–µ –Ω–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã—Ö —Ç–µ–≥–æ–≤ –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∞ <p>
    allowed_tags = ['b', 'strong', 'i', 'em', 'u', 'ins', 's', 'strike', 'del', 'code', 'pre', 'a']

    soup = BeautifulSoup(html_reply, 'html.parser')
    for tag in soup.find_all():
        if tag.name == 'p':
            tag.replace_with(f'{tag.get_text()}\n')  # –ó–∞–º–µ–Ω—è–µ–º <p> —Å–æ–¥–µ—Ä–∂–∏–º—ã–º –∏ –ø–µ—Ä–µ–Ω–æ—Å–æ–º —Å—Ç—Ä–æ–∫–∏
        elif tag.name not in allowed_tags:
            tag.unwrap()  # –£–¥–∞–ª—è–µ–º —Ç–µ–≥, —Å–æ—Ö—Ä–∞–Ω—è—è —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ

    clean_html_reply = str(soup)

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å —É–∫–∞–∑–∞–Ω–∏–µ–º parse_mode
    update.message.reply_text(clean_html_reply, parse_mode=ParseMode.HTML)

    log_interaction(user_id, user_username, user_message, reply)

def main():
    updater = Updater(TELEGRAM_TOKEN)
    dispatcher = updater.dispatcher

    init_db()

    dispatcher.add_handler(CommandHandler("start", start))
    dispatcher.add_handler(CommandHandler("enable", enable_bot))
    dispatcher.add_handler(CommandHandler("disable", disable_bot))
    dispatcher.add_handler(MessageHandler(Filters.text & ~Filters.command, handle_message))

    updater.start_polling()
    updater.idle()

if __name__ == '__main__':
    main()
