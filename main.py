import logging
import os
import random
import re
import requests
import asyncio
from collections import defaultdict
from datetime import datetime
from io import BytesIO

from decouple import config
import openai
import psycopg2
from bs4 import BeautifulSoup
from telegram import Update
from telegram.constants import ParseMode
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    MessageHandler,
    filters,
    ContextTypes,
)
from telegram.helpers import escape_markdown

# Load configuration from .env file
TELEGRAM_TOKEN = config('TELEGRAM_TOKEN')
OPENAI_API_KEY = config('OPENAI_API_KEY')
# NEWS_API_KEY is no longer needed

# PostgreSQL database settings
DB_HOST = config('DB_HOST')
DB_PORT = config('DB_PORT')
DB_NAME = config('DB_NAME')
DB_USER = config('DB_USER')
DB_PASSWORD = config('DB_PASSWORD')

# Set API key for OpenAI
openai.api_key = OPENAI_API_KEY

# Configure logging with reduced verbosity for external libraries
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO,  # Main logger level set to INFO
    handlers=[logging.StreamHandler()]
)
logger = logging.getLogger(__name__)

# Reduce logging level for external libraries
logging.getLogger('httpx').setLevel(logging.WARNING)
logging.getLogger('telegram').setLevel(logging.WARNING)

# Global variables
conversation_context = defaultdict(list)  # Conversation contexts
group_status = defaultdict(bool)  # Bot activation status in groups
user_personalities = defaultdict(str)  # User-specific bot personalities
user_requests = defaultdict(list)  # For rate limiting

# Default bot personality
default_personality = "–¢—ã –°–≤–µ–∫–ª–∞–Ω–∞ - –º–∏–ª–ª–µ–Ω–∏–∞–ª –∂–µ–Ω—Å–∫–æ–≥–æ –ø–æ–ª–∞, –∫–æ—Ç–æ—Ä—ã–π –ø–µ—Ä–µ–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ. –¢—ã –≤–æ–µ–Ω–Ω—ã–π –∏ –ø–æ–ª–∏—Ç–∏—á–µ—Å–∫–∏–π —ç–∫—Å–ø–µ—Ä—Ç, —É–º–µ–µ—à—å –∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –Ω–æ–≤–æ—Å—Ç–∏ –∏ —Å–ª–æ–∂–Ω—ã–µ —Å–∏—Ç—É–∞—Ü–∏–∏."

def get_db_connection():
    """
    Establishes a connection to the PostgreSQL database.
    """
    return psycopg2.connect(
        dbname=DB_NAME,
        user=DB_USER,
        password=DB_PASSWORD,
        host=DB_HOST,
        port=DB_PORT
    )

def add_emojis_at_end(answer: str) -> str:
    """
    Randomly adds emojis to the end of the assistant's reply.
    """
    emojis = ['üòä', 'üòâ', 'üòÑ', 'üéâ', '‚ú®', 'üëç', 'üòÇ', 'üòç', 'üòé', 'ü§î', 'ü•≥', 'üòá', 'üôå', 'üåü']

    if random.choice([True, False]):
        return answer

    num_emojis = random.randint(1, 3)
    chosen_emojis = ''.join(random.choices(emojis, k=num_emojis))

    return f"{answer} {chosen_emojis}"

def init_db():
    """
    Initializes the database and necessary tables.
    """
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS askgbt_logs (
            id SERIAL PRIMARY KEY,
            user_id BIGINT,
            user_username TEXT,
            user_message TEXT,
            gpt_reply TEXT,
            timestamp TIMESTAMP
        )
        ''')
        # Table for storing user personalities
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS user_personalities (
            user_id BIGINT PRIMARY KEY,
            personality TEXT
        )
        ''')
        conn.commit()
        cursor.close()
        conn.close()
        logger.info("Database tables created or already exist")
    except Exception as e:
        logger.error(f"Error initializing database: {str(e)}")

def log_interaction(user_id, user_username, user_message, gpt_reply):
    """
    Logs the user's interaction with the bot in the database.
    """
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        timestamp = datetime.now()
        cursor.execute('''
        INSERT INTO askgbt_logs (user_id, user_username, user_message, gpt_reply, timestamp)
        VALUES (%s, %s, %s, %s, %s)
        ''', (user_id, user_username, user_message, gpt_reply, timestamp))
        conn.commit()
        cursor.close()
        conn.close()
    except Exception as e:
        logger.error(f"Error writing to database: {str(e)}")

async def ask_chatgpt(messages) -> str:
    """
    –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –≤ OpenAI ChatGPT –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ—Ç–≤–µ—Ç.
    """
    logger.info(f"–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ ChatGPT: {messages}")
    try:
        # –î–æ–±–∞–≤–ª—è–µ–º —Å–∏—Å—Ç–µ–º–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –∫–æ–Ω—Ç—Ä–æ–ª—è –¥–ª–∏–Ω—ã –æ—Ç–≤–µ—Ç–∞
        messages_with_formatting = [
            {"role": "system", "content": "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–µ–ª–∞–π –æ—Ç–≤–µ—Ç—ã –∫—Ä–∞—Ç–∫–∏–º–∏ –∏ –Ω–µ –±–æ–ª–µ–µ 3500 —Å–∏–º–≤–æ–ª–æ–≤."}
        ] + messages

        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –º–µ—Ç–æ–¥ OpenAI API
        response = await openai.ChatCompletion.acreate(
            model="gpt-3.5-turbo",
            messages=messages_with_formatting,
            max_tokens=700,
            temperature=0.5,
            n=1
        )

        answer = response.choices[0].message['content'].strip()
        logger.info(f"–û—Ç–≤–µ—Ç ChatGPT: {answer}")

        answer = add_emojis_at_end(answer)

        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –¥–ª–∏–Ω—É —Å–æ–æ–±—â–µ–Ω–∏—è –≤ Telegram
        max_length = 4096
        if len(answer) > max_length:
            answer = answer[:max_length]
            answer = answer.rsplit(' ', 1)[0] + '...'

        return answer
    except openai.error.RateLimitError:
        error_msg = "–ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤ –∫ OpenAI API. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
        logger.error(error_msg)
        return error_msg
    except openai.error.InvalidRequestError as e:
        error_msg = f"–û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –∫ OpenAI API: {str(e)}"
        logger.error(error_msg)
        return error_msg
    except Exception as e:
        logger.error("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞—â–µ–Ω–∏–∏ –∫ ChatGPT", exc_info=True)
        error_msg = f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞—â–µ–Ω–∏–∏ –∫ ChatGPT: {str(e)}"
        return error_msg

def generate_image(prompt: str) -> str:
    """
    Generates an image based on the user's description using OpenAI's API.
    """
    logger.info(f"Requesting image generation with prompt: {prompt}")
    try:
        response = openai.Image.create(
            prompt=prompt,
            n=1,
            size="1024x1024"
        )
        image_url = response['data'][0]['url']
        logger.info(f"Received image URL: {image_url}")
        return image_url
    except Exception as e:
        error_msg = f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {str(e)}"
        logger.error(error_msg)
        return error_msg

async def send_image(update: Update, context: ContextTypes.DEFAULT_TYPE, image_url: str) -> None:
    """
    Sends the generated image to the user.
    """
    try:
        response = requests.get(image_url)
        image = BytesIO(response.content)
        image.name = 'image.png'
        await update.message.reply_photo(photo=image)
    except Exception as e:
        error_msg = f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {str(e)}"
        logger.error(error_msg)
        await update.message.reply_text(error_msg)

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Sends a welcome message when the bot is started.
    """
    await update.message.reply_text('–ü—Ä–∏–≤–µ—Ç! –Ø - –°–≤–µ–∫–ª–∞–Ω–∞, —Ç–≤–æ—è –≤–∏—Ä—Ç—É–∞–ª—å–Ω–∞—è –ø–æ–¥—Ä—É–≥–∞. –î–∞–≤–∞–π –ø–æ–æ–±—â–∞–µ–º—Å—è! üòä')

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Sends a message with available commands and instructions.
    """
    # Check if the command is directed at this bot in a group chat
    message_text = update.message.text
    bot_username = context.bot.username

    if update.message.chat.type != 'private':
        if not re.match(rf'^/help(@{bot_username})?$', message_text.strip()):
            return  # Not directed to this bot

    help_text = (
        "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
        "/start - –ù–∞—á–∞—Ç—å –æ–±—â–µ–Ω–∏–µ —Å –±–æ—Ç–æ–º\n"
        "/help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–º–æ—â–∏\n"
        "/enable - –í–∫–ª—é—á–∏—Ç—å –±–æ—Ç–∞ –≤ —ç—Ç–æ–π –≥—Ä—É–ø–ø–µ (—Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤)\n"
        "/disable - –û—Ç–∫–ª—é—á–∏—Ç—å –±–æ—Ç–∞ –≤ —ç—Ç–æ–π –≥—Ä—É–ø–ø–µ (—Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤)\n"
        "/image [–∑–∞–ø—Ä–æ—Å] - –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ –æ–ø–∏—Å–∞–Ω–∏—é\n"
        "/reset - –°–±—Ä–æ—Å–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é –¥–∏–∞–ª–æ–≥–∞\n"
        "/set_personality [–æ–ø–∏—Å–∞–Ω–∏–µ] - –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ª–∏—á–Ω–æ—Å—Ç—å –±–æ—Ç–∞\n"
        "/news - –ü–æ–ª—É—á–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–µ –Ω–æ–≤–æ—Å—Ç–∏\n"
    )
    await update.message.reply_text(help_text)

async def is_user_admin(update: Update) -> bool:
    """
    Checks if the user is an administrator in the chat.
    """
    user_status = await update.effective_chat.get_member(update.effective_user.id)
    return user_status.status in ['administrator', 'creator']

async def enable_bot(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Enables the bot in the group.
    """
    chat_id = update.message.chat.id
    if await is_user_admin(update):
        group_status[chat_id] = True
        await update.message.reply_text("–ë–æ—Ç –≤–∫–ª—é—á–µ–Ω –≤ —ç—Ç–æ–π –≥—Ä—É–ø–ø–µ!")
    else:
        await update.message.reply_text("–¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä –º–æ–∂–µ—Ç –≤—ã–ø–æ–ª–Ω—è—Ç—å —ç—Ç—É –∫–æ–º–∞–Ω–¥—É.")

async def disable_bot(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Disables the bot in the group.
    """
    chat_id = update.message.chat.id
    if await is_user_admin(update):
        group_status[chat_id] = False
        await update.message.reply_text("–ë–æ—Ç –æ—Ç–∫–ª—é—á–µ–Ω –≤ —ç—Ç–æ–π –≥—Ä—É–ø–ø–µ!")
    else:
        await update.message.reply_text("–¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä –º–æ–∂–µ—Ç –≤—ã–ø–æ–ª–Ω—è—Ç—å —ç—Ç—É –∫–æ–º–∞–Ω–¥—É.")

def is_bot_enabled(chat_id: int) -> bool:
    """
    Checks if the bot is enabled in the given chat.
    """
    return group_status.get(chat_id, False)

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handles incoming text messages and generates a reply using OpenAI.
    """
    if update.message is None:
        return

    chat_id = update.message.chat.id
    user_id = update.message.from_user.id
    user_username = update.message.from_user.username
    message_text = update.message.text.strip()
    bot_username = context.bot.username

    # Check for bot mention or reply in group chats
    if update.message.chat.type != 'private':
        if not is_bot_enabled(chat_id):
            return  # Bot is disabled in this group

        # Condition if the bot is mentioned
        if f'@{bot_username}' in message_text:
            message_text = message_text.replace(f'@{bot_username}', '').strip()
        # Condition if the message is a reply to the bot's message
        elif update.message.reply_to_message and update.message.reply_to_message.from_user.id == context.bot.id:
            pass  # Proceed without modifying message_text
        else:
            return  # Bot is neither mentioned nor replied to

    # Rate limiting
    current_time = datetime.now()
    user_requests[user_id] = [req_time for req_time in user_requests[user_id] if (current_time - req_time).seconds < 60]
    if len(user_requests[user_id]) >= 5:
        await update.message.reply_text("–í—ã —Å–ª–∏—à–∫–æ–º —á–∞—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç–µ –∑–∞–ø—Ä–æ—Å—ã. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ –Ω–µ–º–Ω–æ–≥–æ.")
        return
    user_requests[user_id].append(current_time)

    # Get bot personality for the user
    personality = user_personalities.get(user_id, default_personality)
    initial_instructions = [{"role": "system", "content": personality}]

    # Update conversation context
    conversation_context[user_id].append({"role": "user", "content": message_text})
    conversation_context[user_id] = conversation_context[user_id][-10:]  # Keep last 10 messages

    messages = initial_instructions + conversation_context[user_id]

    reply = await ask_chatgpt(messages)

    conversation_context[user_id].append({"role": "assistant", "content": reply})

    # Escape special characters for Markdown V2
    escaped_reply = escape_markdown(reply, version=2)

    # Ensure the message does not exceed Telegram's limit
    max_length = 4096
    if len(escaped_reply) > max_length:
        escaped_reply = escaped_reply[:max_length]

    # Send the reply
    try:
        await update.message.reply_text(escaped_reply, parse_mode=ParseMode.MARKDOWN_V2)
    except Exception as e:
        logger.error(f"Error sending message: {str(e)}")
        await update.message.reply_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è.")

    log_interaction(user_id, user_username, message_text, reply)
    logger.info(f"User ID: {user_id}, Chat ID: {chat_id}, Message ID: {update.message.message_id}")

async def image_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Generates an image based on the user's description.
    """
    user_input = ' '.join(context.args)
    if not user_input:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø–æ—Å–ª–µ –∫–æ–º–∞–Ω–¥—ã /image.")
        return
    image_url = generate_image(user_input)
    if image_url.startswith("–û—à–∏–±–∫–∞"):
        await update.message.reply_text(image_url)
    else:
        await send_image(update, context, image_url)

async def reset_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Resets the conversation history with the user.
    """
    user_id = update.message.from_user.id
    conversation_context[user_id] = []
    await update.message.reply_text("–ò—Å—Ç–æ—Ä–∏—è –¥–∏–∞–ª–æ–≥–∞ —Å–±—Ä–æ—à–µ–Ω–∞.")

async def set_personality(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Allows the user to set the bot's personality.
    """
    personality = ' '.join(context.args)
    if not personality:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –∂–µ–ª–∞–µ–º—É—é –ª–∏—á–Ω–æ—Å—Ç—å –±–æ—Ç–∞ –ø–æ—Å–ª–µ –∫–æ–º–∞–Ω–¥—ã /set_personality.")
        return

    user_id = update.message.from_user.id
    user_personalities[user_id] = personality

    # Save personality to the database
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute('''
        INSERT INTO user_personalities (user_id, personality)
        VALUES (%s, %s)
        ON CONFLICT (user_id) DO UPDATE SET personality = %s
        ''', (user_id, personality, personality))
        conn.commit()
        cursor.close()
        conn.close()
    except Exception as e:
        logger.error(f"Error saving personality to database: {str(e)}")

    await update.message.reply_text(f"–õ–∏—á–Ω–æ—Å—Ç—å –±–æ—Ç–∞ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞: {personality}")

async def handle_photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handles incoming images.
    """
    await update.message.reply_text("–°–ø–∞—Å–∏–±–æ –∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ! –ù–æ —è –ø–æ–∫–∞ –Ω–µ —É–º–µ—é –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è.")

async def news_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Retrieves the latest news from the BBC RSS feed and sends it to the user.
    """
    try:
        # Use the BBC News RSS feed
        response = requests.get('http://feeds.bbci.co.uk/news/rss.xml')
        response.raise_for_status()  # Check for request errors

        # Parse the XML content
        soup = BeautifulSoup(response.content, features='xml')
        items = soup.findAll('item')[:5]  # Get the first 5 news items

        news_message = "–í–æ—Ç –ø–æ—Å–ª–µ–¥–Ω–∏–µ –Ω–æ–≤–æ—Å—Ç–∏ –æ—Ç BBC:\n\n"
        for item in items:
            title = escape_markdown(item.title.text, version=2)
            link = item.link.text
            news_message += f"*{title}*\n[–ß–∏—Ç–∞—Ç—å –¥–∞–ª—å—à–µ]({link})\n\n"

        # Send the news message
        await update.message.reply_text(
            news_message,
            parse_mode=ParseMode.MARKDOWN_V2,
            disable_web_page_preview=True
        )
    except Exception as e:
        logger.error(f"Error retrieving news: {str(e)}")
        await update.message.reply_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –Ω–æ–≤–æ—Å—Ç–µ–π.")

def main():
    """
    Starts the bot.
    """
    application = ApplicationBuilder().token(TELEGRAM_TOKEN).build()

    init_db()

    # Add command handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("enable", enable_bot))
    application.add_handler(CommandHandler("disable", disable_bot))
    application.add_handler(CommandHandler("image", image_command))
    application.add_handler(CommandHandler("reset", reset_command))
    application.add_handler(CommandHandler("set_personality", set_personality))
    application.add_handler(CommandHandler("news", news_command))

    # Add message handlers
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    application.add_handler(MessageHandler(filters.PHOTO, handle_photo))

    # Run the bot
    application.run_polling()

if __name__ == '__main__':
    import asyncio
    asyncio.run(main())
