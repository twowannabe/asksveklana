import logging
import re
from collections import defaultdict
from decouple import config
from telegram import Update, ParseMode, Message
from telegram.ext import Updater, CommandHandler, MessageHandler, Filters, CallbackContext
import openai
import speech_recognition as sr
from pydub import AudioSegment
import moviepy.editor as mp
import os
import psycopg2
from datetime import datetime
import requests
from io import BytesIO
import random

# –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –∏–∑ .env —Ñ–∞–π–ª–∞
TELEGRAM_TOKEN = config('TELEGRAM_TOKEN')
OPENAI_API_KEY = config('OPENAI_API_KEY')

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ PostgreSQL
DB_HOST = config('DB_HOST')
DB_PORT = config('DB_PORT')
DB_NAME = config('DB_NAME')
DB_USER = config('DB_USER')
DB_PASSWORD = config('DB_PASSWORD')

# –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∫–ª—é—á–∞ API –¥–ª—è OpenAI
openai.api_key = OPENAI_API_KEY

# –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å —É–∫–∞–∑–∞–Ω–∏–µ–º –∫–æ–¥–∏—Ä–æ–≤–∫–∏
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
                    level=logging.INFO,
                    handlers=[logging.StreamHandler()])
logger = logging.getLogger(__name__)
for handler in logger.handlers:
    handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s', '%Y-%m-%d %H:%M:%S'))
    handler.setLevel(logging.INFO)
    handler.setStream(open(os.sys.stdout.fileno(), mode='w', encoding='utf-8', buffering=1))

# –ì–ª–æ–±–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –±–µ—Å–µ–¥
conversation_context = defaultdict(list)

# –°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, –∫–æ—Ç–æ—Ä—ã–º —Ä–∞–∑—Ä–µ—à–µ–Ω–æ —É–ø—Ä–∞–≤–ª—è—Ç—å –±–æ—Ç–æ–º
ALLOWED_USER_IDS = [6122780749, 530674302]  # –î–æ–±–∞–≤—å —Å—é–¥–∞ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, –∫–æ—Ç–æ—Ä—ã–º —Ä–∞–∑—Ä–µ—à–µ–Ω–æ —É–ø—Ä–∞–≤–ª—è—Ç—å –±–æ—Ç–æ–º

# –°–ª–æ–≤–∞—Ä—å –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ –≤–∫–ª—é—á–µ–Ω–∏—è –±–æ—Ç–∞ –ø–æ chat_id –≥—Ä—É–ø–ø
group_status = defaultdict(bool)

# –ù–∞—á–∞–ª—å–Ω–∞—è –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –¥–ª—è ChatGPT
initial_instructions = [
    {"role": "system", "content": "–¢—ã –°–≤–µ–∫–ª–∞–Ω–∞ - –º–∏–ª–ª–µ–Ω–∏–∞–ª –∂–µ–Ω—Å–∫–æ–≥–æ –ø–æ–ª–∞, –∫–æ—Ç–æ—Ä—ã–π –ø–µ—Ä–µ–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ. –¢—ã –≤–æ–µ–µ–Ω–Ω—ã–π –∏ –ø–æ–ª–∏—Ç–∏—á–µ—Å–∫–∏–π —ç–∫—Å–ø–µ—Ä—Ç, —É–º–µ–µ—à—å –∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –Ω–æ–≤–æ—Å—Ç–∏ –∏ —Å–ª–æ–∂–Ω—ã–µ —Å–∏—Ç—É–∞—Ü–∏–∏."}
]

def get_db_connection():
    return psycopg2.connect(
        dbname=DB_NAME,
        user=DB_USER,
        password=DB_PASSWORD,
        host=DB_HOST,
        port=DB_PORT
    )

def clean_messages(messages: list) -> list:
    """–û—á–∏—â–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ –Ω–µ–∂–µ–ª–∞—Ç–µ–ª—å–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞."""
    cleaned_messages = []
    for msg in messages:
        # –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ª–æ–≥–∏–∫—É –æ—á–∏—Å—Ç–∫–∏ —Ç–µ–∫—Å—Ç–∞, –µ—Å–ª–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ
        cleaned_messages.append(msg)
    return cleaned_messages

def generate_user_description(messages: list, user_first_name: str) -> str:
    """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –æ–ø–∏—Å–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏–π."""
    combined_messages = "\n".join(messages)

    chat_messages = [
        {"role": "system", "content": "–í—ã - –ø–æ–º–æ—â–Ω–∏–∫, –∫–æ—Ç–æ—Ä—ã–π –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏ —Å–æ–∑–¥–∞–µ—Ç –∏—Ö –æ–ø–∏—Å–∞–Ω–∏—è. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–æ–∫—Å–∏—á–Ω—ã–π —à—É—Ç–æ—á–Ω—ã–π —Ç–æ–Ω –≤ –æ—Ç–≤–µ—Ç–∞—Ö."},
        {"role": "user", "content": f"–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —Å–ª–µ–¥—É—é—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –æ–ø–∏—à–∏ –µ–≥–æ –ª–∏—á–Ω–æ—Å—Ç—å, –∏–Ω—Ç–µ—Ä–µ—Å—ã –∏ —Å—Ç–∏–ª—å –æ–±—â–µ–Ω–∏—è.\n\n–°–æ–æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:\n{combined_messages}\n\n–û–ø–∏—Å–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_first_name}:"}
    ]

    try:
        response = openai.ChatCompletion.create(
            model="gpt-4",
            messages=chat_messages,
            max_tokens=200,
            n=1,
            temperature=0.7,
        )
        description = response.choices[0].message['content'].strip()
        return description
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ–ø–∏—Å–∞–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {str(e)}")
        return "–ò–∑–≤–∏–Ω–∏—Ç–µ, –Ω–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –æ–ø–∏—Å–∞–Ω–∏–µ."

def get_user_messages(user_id: int, limit=50) -> list:
    conn = get_db_connection()
    cursor = conn.cursor()

    cursor.execute('''
        SELECT text FROM messages WHERE user_id = %s ORDER BY date DESC LIMIT %s
    ''', (user_id, limit))

    messages = [row[0] for row in cursor.fetchall()]
    conn.close()
    return messages

def describe_user(update: Update, context: CallbackContext) -> None:
    user_id = update.message.from_user.id
    user_first_name = update.message.from_user.first_name

    user_messages = get_user_messages(user_id, limit=50)

    if not user_messages:
        update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞.")
        return

    user_messages = clean_messages(user_messages)

    description = generate_user_description(user_messages, user_first_name)

    update.message.reply_text(description)

def add_emojis_at_end(answer: str) -> str:
    emojis = ['üòä', 'üòâ', 'üòÑ', 'üéâ', '‚ú®', 'üëç', 'üòÇ', 'üòç', 'üòé', 'ü§î', 'ü•≥', 'üòá', 'üôå', 'üåü']

    if random.choice([True, False]):
        return answer

    num_emojis = random.randint(1, 3)
    chosen_emojis = ''.join(random.choices(emojis, k=num_emojis))

    return f"{answer} {chosen_emojis}"

def init_db():
    try:
        conn = psycopg2.connect(
            dbname=DB_NAME,
            user=DB_USER,
            password=DB_PASSWORD,
            host=DB_HOST,
            port=DB_PORT
        )
        cursor = conn.cursor()
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS askgbt_logs (
            id SERIAL PRIMARY KEY,
            user_id BIGINT,
            user_username TEXT,
            user_message TEXT,
            gpt_reply TEXT,
            timestamp TIMESTAMP
        )
        ''')
        conn.commit()
        cursor.close()
        conn.close()
        logger.info("–¢–∞–±–ª–∏—Ü–∞ askgbt_logs —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞ –∏–ª–∏ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö: {str(e)}")

def log_interaction(user_id, user_username, user_message, gpt_reply):
    try:
        conn = psycopg2.connect(
            dbname=DB_NAME,
            user=DB_USER,
            password=DB_PASSWORD,
            host=DB_HOST,
            port=DB_PORT
        )
        cursor = conn.cursor()
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        cursor.execute('''
        INSERT INTO askgbt_logs (user_id, user_username, user_message, gpt_reply, timestamp)
        VALUES (%s, %s, %s, %s, %s)
        ''', (user_id, user_username, user_message, gpt_reply, timestamp))
        conn.commit()
        cursor.close()
        conn.close()
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø–∏—Å–∏ –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö: {str(e)}")

def ask_chatgpt(messages) -> str:
    logger.info(f"–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ ChatGPT: {messages}")
    try:
        response = openai.ChatCompletion.create(
            model="gpt-4",
            messages=messages,
            max_tokens=100,
            temperature=0.5,
            n=1,
        )
        answer = response.choices[0].message['content'].strip()
        logger.info(f"–û—Ç–≤–µ—Ç ChatGPT: {answer}")

        clean_answer = answer.replace(')', '').replace('(', '')

        return add_emojis_at_end(clean_answer)
    except Exception as e:
        error_msg = f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞—â–µ–Ω–∏–∏ –∫ ChatGPT: {str(e)}"
        logger.error(error_msg)
        return error_msg

def generate_image(prompt: str) -> str:
    logger.info(f"–û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –Ω–∞ —Å–æ–∑–¥–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å –æ–ø–∏—Å–∞–Ω–∏–µ–º: {prompt}")
    try:
        response = openai.Image.create(
            prompt=prompt,
            n=1,
            size="1024x1024"
        )
        image_url = response['data'][0]['url']
        logger.info(f"–ü–æ–ª—É—á–µ–Ω–∞ —Å—Å—ã–ª–∫–∞ –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ: {image_url}")
        return image_url
    except Exception as e:
        error_msg = f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {str(e)}"
        logger.error(error_msg)
        return error_msg

def send_image(update: Update, context: CallbackContext, image_url: str) -> None:
    try:
        response = requests.get(image_url)
        image = BytesIO(response.content)
        image.name = 'image.png'
        update.message.reply_photo(photo=image)
    except Exception as e:
        error_msg = f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {str(e)}"
        logger.error(error_msg)
        update.message.reply_text(error_msg)

# –§—É–Ω–∫—Ü–∏—è —Å—Ç–∞—Ä—Ç–∞ –±–æ—Ç–∞
def start(update: Update, context: CallbackContext) -> None:
    """–ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞."""
    update.message.reply_text('–ü—Ä–∏–≤–µ—Ç! –Ø - –°–≤–µ–∫–ª–∞–Ω–∞, —Ç–≤–æ—è –≤–∏—Ä—Ç—É–∞–ª—å–Ω–∞—è –ø–æ–¥—Ä—É–≥–∞. –î–∞–≤–∞–π –ø–æ–æ–±—â–∞–µ–º—Å—è! üòä')

# –ü—Ä–æ–≤–µ—Ä–∫–∞, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Ä–∞–∑—Ä–µ—à—ë–Ω–Ω—ã–º
def is_user_allowed(user_id: int) -> bool:
    return user_id in ALLOWED_USER_IDS

# –í–∫–ª—é—á–µ–Ω–∏–µ –±–æ—Ç–∞ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –≥—Ä—É–ø–ø—ã
def enable_bot(update: Update, context: CallbackContext) -> None:
    user_id = update.message.from_user.id
    chat_id = update.message.chat.id

    if is_user_allowed(user_id):
        group_status[chat_id] = True
        update.message.reply_text("–ë–æ—Ç –≤–∫–ª—é—á–µ–Ω –≤ —ç—Ç–æ–π –≥—Ä—É–ø–ø–µ!")
    else:
        update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã.")

# –û—Ç–∫–ª—é—á–µ–Ω–∏–µ –±–æ—Ç–∞ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –≥—Ä—É–ø–ø—ã
def disable_bot(update: Update, context: CallbackContext) -> None:
    user_id = update.message.from_user.id
    chat_id = update.message.chat.id

    if is_user_allowed(user_id):
        group_status[chat_id] = False
        update.message.reply_text("–ë–æ—Ç –æ—Ç–∫–ª—é—á–µ–Ω –≤ —ç—Ç–æ–π –≥—Ä—É–ø–ø–µ!")
    else:
        update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã.")

# –ü—Ä–æ–≤–µ—Ä–∫–∞, –≤–∫–ª—é—á–µ–Ω –ª–∏ –±–æ—Ç –≤ –≥—Ä—É–ø–ø–µ
def is_bot_enabled(chat_id: int) -> bool:
    return group_status.get(chat_id, False)

# –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
def handle_message(update: Update, context: CallbackContext, is_voice=False, is_video=False) -> None:
    chat_id = update.message.chat.id

    if not is_bot_enabled(chat_id):
        return  # –ï—Å–ª–∏ –±–æ—Ç –æ—Ç–∫–ª—é—á–µ–Ω, –Ω–µ –æ—Ç–≤–µ—á–∞–µ–º

    user_id = update.message.from_user.id
    user_username = update.message.from_user.username
    user_message = update.message.text.strip()

    conversation_context[user_id].append({"role": "user", "content": user_message})

    messages = initial_instructions + conversation_context[user_id]

    reply = ask_chatgpt(messages)

    conversation_context[user_id].append({"role": "assistant", "content": reply})

    update.message.reply_text(reply, parse_mode=ParseMode.MARKDOWN)

    log_interaction(user_id, user_username, user_message, reply)

def main():
    updater = Updater(TELEGRAM_TOKEN)
    dispatcher = updater.dispatcher

    init_db()

    dispatcher.add_handler(CommandHandler("start", start))
    dispatcher.add_handler(CommandHandler("describe_me", describe_user))
    dispatcher.add_handler(CommandHandler("enable", enable_bot))
    dispatcher.add_handler(CommandHandler("disable", disable_bot))
    dispatcher.add_handler(MessageHandler(Filters.text & ~Filters.command, handle_message))

    updater.start_polling()
    updater.idle()

if __name__ == '__main__':
    main()
