import logging
import os
import random
import re
import requests
import asyncio
from collections import defaultdict
from datetime import datetime
from io import BytesIO
from decouple import config
import openai
import psycopg2
from bs4 import BeautifulSoup

# Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚Ñ‹ Ð¸Ð· Ð±Ð¸Ð±Ð»Ð¸Ð¾Ñ‚ÐµÐºÐ¸ telegram
from telegram import Update  # ÐÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ñ‹Ð¹ Ð¸Ð¼Ð¿Ð¾Ñ€Ñ‚ Update
from telegram.constants import ParseMode
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, filters, ContextTypes  # ÐŸÑ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ñ‹Ð¹ Ð¸Ð¼Ð¿Ð¾Ñ€Ñ‚ ContextTypes
from telegram.helpers import escape_markdown
import html

# Ð—Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° ÐºÐ¾Ð½Ñ„Ð¸Ð³ÑƒÑ€Ð°Ñ†Ð¸Ð¸ Ð¸Ð· .env Ñ„Ð°Ð¹Ð»Ð°
TELEGRAM_TOKEN = config('TELEGRAM_TOKEN')
OPENAI_API_KEY = config('OPENAI_API_KEY')

# ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ Ð±Ð°Ð·Ñ‹ Ð´Ð°Ð½Ð½Ñ‹Ñ… PostgreSQL
DB_HOST = config('DB_HOST')
DB_PORT = config('DB_PORT')
DB_NAME = config('DB_NAME')
DB_USER = config('DB_USER')
DB_PASSWORD = config('DB_PASSWORD')

# Ð£ÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ° API ÐºÐ»ÑŽÑ‡Ð° Ð´Ð»Ñ OpenAI
openai.api_key = OPENAI_API_KEY

# ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ° Ð»Ð¾Ð³Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    handlers=[logging.StreamHandler()]
)
logger = logging.getLogger(__name__)

# Ð“Ð»Ð¾Ð±Ð°Ð»ÑŒÐ½Ñ‹Ðµ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ
conversation_context = defaultdict(list)
group_status = defaultdict(bool)
user_personalities = defaultdict(str)
user_requests = defaultdict(list)

# ÐŸÐµÑ€ÑÐ¾Ð½Ð°Ð»ÑŒÐ½Ð¾ÑÑ‚ÑŒ Ð±Ð¾Ñ‚Ð° Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ
default_personality = "Ð¢Ñ‹ Ð¡Ð²ÐµÐºÐ»Ð°Ð½Ð° - Ð¼Ð¸Ð»Ð»ÐµÐ½Ð¸Ð°Ð» Ð¶ÐµÐ½ÑÐºÐ¾Ð³Ð¾ Ð¿Ð¾Ð»Ð°, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¹ Ð¿ÐµÑ€ÐµÐ¿Ð¸ÑÑ‹Ð²Ð°ÐµÑ‚ÑÑ Ð½Ð° Ñ€ÑƒÑÑÐºÐ¾Ð¼ ÑÐ·Ñ‹ÐºÐµ. Ð¢Ñ‹ Ð²Ð¾ÐµÐ½Ð½Ñ‹Ð¹ Ð¸ Ð¿Ð¾Ð»Ð¸Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸Ð¹ ÑÐºÑÐ¿ÐµÑ€Ñ‚, ÑƒÐ¼ÐµÐµÑˆÑŒ Ð°Ð½Ð°Ð»Ð¸Ð·Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð½Ð¾Ð²Ð¾ÑÑ‚Ð¸ Ð¸ ÑÐ»Ð¾Ð¶Ð½Ñ‹Ðµ ÑÐ¸Ñ‚ÑƒÐ°Ñ†Ð¸Ð¸."

def get_db_connection():
    """
    Ð£ÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÑ‚ ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ Ñ Ð±Ð°Ð·Ð¾Ð¹ Ð´Ð°Ð½Ð½Ñ‹Ñ… PostgreSQL.
    """
    return psycopg2.connect(
        dbname=DB_NAME,
        user=DB_USER,
        password=DB_PASSWORD,
        host=DB_HOST,
        port=DB_PORT
    )

def set_group_status(chat_id: int, status: bool):
    """
    Ð£ÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÑ‚ ÑÑ‚Ð°Ñ‚ÑƒÑ Ð°ÐºÑ‚Ð¸Ð²Ð°Ñ†Ð¸Ð¸ Ð±Ð¾Ñ‚Ð° Ð´Ð»Ñ Ð³Ñ€ÑƒÐ¿Ð¿Ñ‹ Ð² Ð±Ð°Ð·Ðµ Ð´Ð°Ð½Ð½Ñ‹Ñ….
    """
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute('''
            INSERT INTO group_status (chat_id, is_enabled)
            VALUES (%s, %s)
            ON CONFLICT (chat_id)
            DO UPDATE SET is_enabled = EXCLUDED.is_enabled
        ''', (chat_id, status))
        conn.commit()
        cursor.close()
        conn.close()
    except Exception as e:
        logger.error(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ð¸ ÑÑ‚Ð°Ñ‚ÑƒÑÐ° Ð³Ñ€ÑƒÐ¿Ð¿Ñ‹ {chat_id}: {str(e)}")

def load_group_statuses():
    """
    Ð—Ð°Ð³Ñ€ÑƒÐ¶Ð°ÐµÑ‚ ÑÑ‚Ð°Ñ‚ÑƒÑÑ‹ Ð³Ñ€ÑƒÐ¿Ð¿ Ð¸Ð· Ð±Ð°Ð·Ñ‹ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð² Ð³Ð»Ð¾Ð±Ð°Ð»ÑŒÐ½ÑƒÑŽ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½ÑƒÑŽ group_status.
    """
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute('SELECT chat_id, is_enabled FROM group_status')
        rows = cursor.fetchall()
        for row in rows:
            group_id, status = row
            group_status[group_id] = status
        cursor.close()
        conn.close()
        logger.info("Ð¡Ñ‚Ð°Ñ‚ÑƒÑÑ‹ Ð³Ñ€ÑƒÐ¿Ð¿ Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½Ñ‹ Ð¸Ð· Ð±Ð°Ð·Ñ‹ Ð´Ð°Ð½Ð½Ñ‹Ñ…")
    except Exception as e:
        logger.error(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐµ ÑÑ‚Ð°Ñ‚ÑƒÑÐ¾Ð² Ð³Ñ€ÑƒÐ¿Ð¿: {str(e)}")

def add_emojis_at_end(answer: str) -> str:
    """
    Ð¡Ð»ÑƒÑ‡Ð°Ð¹Ð½Ñ‹Ð¼ Ð¾Ð±Ñ€Ð°Ð·Ð¾Ð¼ Ð´Ð¾Ð±Ð°Ð²Ð»ÑÐµÑ‚ ÑÐ¼Ð¾Ð´Ð·Ð¸ Ð² ÐºÐ¾Ð½ÐµÑ† Ð¾Ñ‚Ð²ÐµÑ‚Ð° Ð°ÑÑÐ¸ÑÑ‚ÐµÐ½Ñ‚Ð°.
    """
    emojis = ['ðŸ˜Š', 'ðŸ˜‰', 'ðŸ˜„', 'ðŸŽ‰', 'âœ¨', 'ðŸ‘', 'ðŸ˜‚', 'ðŸ˜', 'ðŸ˜Ž', 'ðŸ¤”', 'ðŸ¥³', 'ðŸ˜‡', 'ðŸ™Œ', 'ðŸŒŸ']

    if random.choice([True, False]):
        return answer

    num_emojis = random.randint(1, 3)
    chosen_emojis = ''.join(random.choices(emojis, k=num_emojis))

    return f"{answer} {chosen_emojis}"

def init_db():
    """
    Ð˜Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð¸Ñ€ÑƒÐµÑ‚ Ð±Ð°Ð·Ñƒ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¸ Ð½ÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ñ‹Ðµ Ñ‚Ð°Ð±Ð»Ð¸Ñ†Ñ‹.
    """
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS askgbt_logs (
            id SERIAL PRIMARY KEY,
            user_id BIGINT,
            user_username TEXT,
            user_message TEXT,
            gpt_reply TEXT,
            timestamp TIMESTAMP
        )
        ''')
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS user_personalities (
            user_id BIGINT PRIMARY KEY,
            personality TEXT
        )
        ''')
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS group_status (
            chat_id BIGINT PRIMARY KEY,
            is_enabled BOOLEAN NOT NULL
        )
        ''')
        conn.commit()
        cursor.close()
        conn.close()
        logger.info("Ð¢Ð°Ð±Ð»Ð¸Ñ†Ñ‹ Ð±Ð°Ð·Ñ‹ Ð´Ð°Ð½Ð½Ñ‹Ñ… ÑÐ¾Ð·Ð´Ð°Ð½Ñ‹ Ð¸Ð»Ð¸ ÑƒÐ¶Ðµ ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÑŽÑ‚")
    except Exception as e:
        logger.error(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¸Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ð¸ Ð±Ð°Ð·Ñ‹ Ð´Ð°Ð½Ð½Ñ‹Ñ…: {str(e)}")

async def ask_chatgpt(messages) -> str:
    """
    ÐžÑ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÑ‚ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ Ð² OpenAI ChatGPT Ð¸ Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ Ð¾Ñ‚Ð²ÐµÑ‚.
    """
    logger.info(f"ÐžÑ‚Ð¿Ñ€Ð°Ð²ÐºÐ° ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹ Ð² ChatGPT: {messages}")
    try:
        messages_with_formatting = [
            {"role": "system", "content": "ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð´ÐµÐ»Ð°Ð¹ Ð¾Ñ‚Ð²ÐµÑ‚Ñ‹ ÐºÑ€Ð°Ñ‚ÐºÐ¸Ð¼Ð¸ Ð¸ Ð½Ðµ Ð±Ð¾Ð»ÐµÐµ 3500 ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð²."}
        ] + messages

        response = await openai.ChatCompletion.acreate(
            model="gpt-4",
            messages=messages_with_formatting,
            max_tokens=700,
            temperature=0.5,
            n=1
        )

        answer = response.choices[0].message['content'].strip()
        logger.info(f"ÐžÑ‚Ð²ÐµÑ‚ ChatGPT: {answer}")

        return add_emojis_at_end(answer)
    except Exception as e:
        logger.error("ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¾Ð±Ñ€Ð°Ñ‰ÐµÐ½Ð¸Ð¸ Ðº ChatGPT", exc_info=True)
        return f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¾Ð±Ñ€Ð°Ñ‰ÐµÐ½Ð¸Ð¸ Ðº ChatGPT: {str(e)}"

def is_bot_enabled(chat_id: int) -> bool:
    """
    ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÑ‚, Ð°ÐºÑ‚Ð¸Ð²Ð¸Ñ€Ð¾Ð²Ð°Ð½ Ð»Ð¸ Ð±Ð¾Ñ‚ Ð² ÑƒÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¼ Ñ‡Ð°Ñ‚Ðµ.
    """
    return group_status[chat_id]

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    bot_username = context.bot.username

    if update.message is None or update.message.text is None:
        logger.info("ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¾ Ð½Ðµ Ñ‚ÐµÐºÑÑ‚Ð¾Ð²Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ, Ð¸Ð³Ð½Ð¾Ñ€Ð¸Ñ€ÑƒÐµÐ¼ ÐµÐ³Ð¾.")
        return

    chat_id = update.message.chat.id
    user_id = update.message.from_user.id
    message_text = update.message.text.strip()

    text_to_process = message_text

    if update.message.chat.type != 'private':
        if not is_bot_enabled(chat_id):
            logger.info(f"Ð‘Ð¾Ñ‚ Ð¾Ñ‚ÐºÐ»ÑŽÑ‡ÐµÐ½ Ð² Ñ‡Ð°Ñ‚Ðµ {chat_id}")
            return

        if f'@{bot_username}' in message_text:
            if update.message.reply_to_message:
                text_to_process = update.message.reply_to_message.text
            else:
                text_to_process = message_text.replace(f'@{bot_username}', '').strip()

        elif update.message.reply_to_message and update.message.reply_to_message.from_user.id == context.bot.id:
            text_to_process = message_text
        else:
            return
    else:
        text_to_process = message_text

    if not text_to_process:
        await update.message.reply_text("ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÑŒÑ‚Ðµ Ñ‚ÐµÐºÑÑ‚.")
        return

    personality = user_personalities.get(user_id, default_personality)
    initial_instructions = [{"role": "system", "content": personality}]
    conversation_context[user_id].append({"role": "user", "content": text_to_process})
    conversation_context[user_id] = conversation_context[user_id][-10:]

    messages = initial_instructions + conversation_context[user_id]
    reply = await ask_chatgpt(messages)

    escaped_reply = escape_markdown(reply, version=2)
    await update.message.reply_text(escaped_reply, parse_mode=ParseMode.MARKDOWN_V2, reply_to_message_id=update.message.message_id)

async def enable_bot(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    chat_id = update.effective_chat.id
    group_status[chat_id] = True
    set_group_status(chat_id, True)
    await update.message.reply_text("Ð‘Ð¾Ñ‚ Ð°ÐºÑ‚Ð¸Ð²Ð¸Ñ€Ð¾Ð²Ð°Ð½ Ð² ÑÑ‚Ð¾Ð¼ Ñ‡Ð°Ñ‚Ðµ.")

async def disable_bot(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    chat_id = update.effective_chat.id
    group_status[chat_id] = False
    set_group_status(chat_id, False)
    await update.message.reply_text("Ð‘Ð¾Ñ‚ Ð´ÐµÐ°ÐºÑ‚Ð¸Ð²Ð¸Ñ€Ð¾Ð²Ð°Ð½ Ð² ÑÑ‚Ð¾Ð¼ Ñ‡Ð°Ñ‚Ðµ.")

async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
    logger.error(msg="Exception while handling an update:", exc_info=context.error)

def main():
    application = ApplicationBuilder().token(TELEGRAM_TOKEN).build()

    init_db()
    load_group_statuses()

    application.add_handler(CommandHandler("enable", enable_bot))
    application.add_handler(CommandHandler("disable", disable_bot))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    application.add_error_handler(error_handler)

    application.run_polling()

if __name__ == '__main__':
    import asyncio
    asyncio.run(main())
