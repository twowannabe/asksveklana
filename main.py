import logging
import re
from collections import defaultdict
from decouple import config
from telegram import Update, ParseMode, Message
from telegram.ext import Updater, CommandHandler, MessageHandler, Filters, CallbackContext
import openai
import speech_recognition as sr
from pydub import AudioSegment
import moviepy.editor as mp
import os
import psycopg2
from datetime import datetime
import requests
from io import BytesIO
import random

# –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –∏–∑ .env —Ñ–∞–π–ª–∞
TELEGRAM_TOKEN = config('TELEGRAM_TOKEN')
OPENAI_API_KEY = config('OPENAI_API_KEY')

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ PostgreSQL
DB_HOST = config('DB_HOST')
DB_PORT = config('DB_PORT')
DB_NAME = config('DB_NAME')
DB_USER = config('DB_USER')
DB_PASSWORD = config('DB_PASSWORD')

# –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∫–ª—é—á–∞ API –¥–ª—è OpenAI
openai.api_key = OPENAI_API_KEY

# –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å —É–∫–∞–∑–∞–Ω–∏–µ–º –∫–æ–¥–∏—Ä–æ–≤–∫–∏
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
                    level=logging.INFO,
                    handlers=[logging.StreamHandler()])
logger = logging.getLogger(__name__)
for handler in logger.handlers:
    handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s', '%Y-%m-%d %H:%M:%S'))
    handler.setLevel(logging.INFO)
    handler.setStream(open(os.sys.stdout.fileno(), mode='w', encoding='utf-8', buffering=1))

# –ì–ª–æ–±–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –±–µ—Å–µ–¥
conversation_context = defaultdict(list)

# –ù–∞—á–∞–ª—å–Ω–∞—è –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –¥–ª—è ChatGPT
initial_instructions = [
    {"role": "system", "content": "–¢—ã –°–≤–µ–∫–ª–∞–Ω–∞ - –º–∏–ª–ª–µ–Ω–∏–∞–ª –∂–µ–Ω—Å–∫–æ–≥–æ –ø–æ–ª–∞, –∫–æ—Ç–æ—Ä—ã–π –ø–µ—Ä–µ–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ. –¢—ã –æ—Ç–≤–µ—á–∞–µ—à—å –∫—Ä–∞—Ç–∫–æ –∏ –ø–æ –¥–µ–ª—É, –∏–∑–±–µ–≥–∞—è –ª–∏—à–Ω–∏—Ö —Å–ª–æ–≤."}
]

def get_db_connection():
    return psycopg2.connect(
        dbname=DB_NAME,
        user=DB_USER,
        password=DB_PASSWORD,
        host=DB_HOST,
        port=DB_PORT
    )

def clean_messages(messages: list) -> list:
    """–û—á–∏—â–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ –Ω–µ–∂–µ–ª–∞—Ç–µ–ª—å–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞."""
    cleaned_messages = []
    for msg in messages:
        # –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ª–æ–≥–∏–∫—É –æ—á–∏—Å—Ç–∫–∏ —Ç–µ–∫—Å—Ç–∞, –µ—Å–ª–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ
        cleaned_messages.append(msg)
    return cleaned_messages

def generate_user_description(messages: list, user_first_name: str) -> str:
    """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –æ–ø–∏—Å–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏–π."""
    # –û–±—ä–µ–¥–∏–Ω—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è –≤ –æ–¥–∏–Ω —Ç–µ–∫—Å—Ç
    combined_messages = "\n".join(messages)

    # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ ChatGPT
    chat_messages = [
        {"role": "system", "content": "–í—ã - –ø–æ–º–æ—â–Ω–∏–∫, –∫–æ—Ç–æ—Ä—ã–π –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏ —Å–æ–∑–¥–∞–µ—Ç –∏—Ö –æ–ø–∏—Å–∞–Ω–∏—è. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–æ–∫—Å–∏—á–Ω—ã–π —à—É—Ç–æ—á–Ω—ã–π —Ç–æ–Ω –≤ –æ—Ç–≤–µ—Ç–∞—Ö."},
        {"role": "user", "content": f"–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —Å–ª–µ–¥—É—é—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –æ–ø–∏—à–∏ –µ–≥–æ –ª–∏—á–Ω–æ—Å—Ç—å, –∏–Ω—Ç–µ—Ä–µ—Å—ã –∏ —Å—Ç–∏–ª—å –æ–±—â–µ–Ω–∏—è.\n\n–°–æ–æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:\n{combined_messages}\n\n–û–ø–∏—Å–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_first_name}:"}
    ]

    try:
        response = openai.ChatCompletion.create(
            model="gpt-4o-mini",  # –ò–ª–∏ "gpt-3.5-turbo", –µ—Å–ª–∏ —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ GPT-4
            messages=chat_messages,
            max_tokens=200,
            n=1,
            temperature=0.7,
        )
        description = response.choices[0].message['content'].strip()
        return description
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ–ø–∏—Å–∞–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {str(e)}")
        return "–ò–∑–≤–∏–Ω–∏—Ç–µ, –Ω–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –æ–ø–∏—Å–∞–Ω–∏–µ."

def get_user_messages(user_id: int, limit=50) -> list:
    """–ü–æ–ª—É—á–∞–µ—Ç –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö."""
    conn = get_db_connection()
    cursor = conn.cursor()

    cursor.execute('''
        SELECT text FROM messages WHERE user_id = %s ORDER BY date DESC LIMIT %s
    ''', (user_id, limit))

    messages = [row[0] for row in cursor.fetchall()]
    conn.close()
    return messages

def describe_user(update: Update, context: CallbackContext) -> None:
    user_id = update.message.from_user.id
    user_first_name = update.message.from_user.first_name

    # –ü–æ–ª—É—á–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
    user_messages = get_user_messages(user_id, limit=50)

    if not user_messages:
        update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞.")
        return

    # –û—á–∏—â–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è
    user_messages = clean_messages(user_messages)

    # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏–π
    description = generate_user_description(user_messages, user_first_name)

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
    update.message.reply_text(description)

def add_emojis_at_end(answer: str) -> str:
    """–î–æ–±–∞–≤–ª—è–µ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ —ç–º–æ–¥–∑–∏ –≤ –∫–æ–Ω–µ—Ü –æ—Ç–≤–µ—Ç–∞."""
    emojis = ['üòä', 'üòâ', 'üòÑ', 'üéâ', '‚ú®', 'üëç', 'üòÇ', 'üòç', 'üòé', 'ü§î', 'ü•≥', 'üòá', 'üôå', 'üåü']

    if random.choice([True, False]):
        return answer

    num_emojis = random.randint(1, 3)
    chosen_emojis = ''.join(random.choices(emojis, k=num_emojis))

    return f"{answer} {chosen_emojis}"

# –°–æ–∑–¥–∞–Ω–∏–µ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
# –°–æ–∑–¥–∞–Ω–∏–µ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
# –°–æ–∑–¥–∞–Ω–∏–µ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
def init_db():
    try:
        conn = psycopg2.connect(
            dbname=DB_NAME,
            user=DB_USER,
            password=DB_PASSWORD,
            host=DB_HOST,
            port=DB_PORT
        )
        cursor = conn.cursor()
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS askgbt_logs (
            id SERIAL PRIMARY KEY,
            user_id BIGINT,
            user_username TEXT,
            user_message TEXT,
            gpt_reply TEXT,
            timestamp TIMESTAMP
        )
        ''')
        conn.commit()
        cursor.close()
        conn.close()
        logger.info("–¢–∞–±–ª–∏—Ü–∞ askgbt_logs —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞ –∏–ª–∏ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö: {str(e)}")

# –û—á–∏—Å—Ç–∫–∞ –∑–∞–ø—Ä–æ—Å–æ–≤ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
def clean_drawing_prompt(prompt: str) -> str:
    drawing_keywords = ["–Ω–∞—Ä–∏—Å—É–π", "—Å–æ–∑–¥–∞–π", "–∏–∑–æ–±—Ä–∞–∑–∏", "—Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π", "–ø–æ–∫–∞–∂–∏ –∫–∞—Ä—Ç–∏–Ω–∫—É", "—Å–¥–µ–ª–∞–π –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ"]
    for keyword in drawing_keywords:
        if keyword in prompt.lower():
            prompt = prompt.lower().replace(keyword, "").strip()
    return prompt

def is_drawing_request(message: str) -> bool:
    drawing_keywords = ["–Ω–∞—Ä–∏—Å—É–π", "—Å–æ–∑–¥–∞–π", "–∏–∑–æ–±—Ä–∞–∑–∏", "—Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π", "–ø–æ–∫–∞–∂–∏ –∫–∞—Ä—Ç–∏–Ω–∫—É", "—Å–¥–µ–ª–∞–π –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ", "–ø–æ–∫–∞–∂–∏ –∫–∞–∫ –≤—ã–≥–ª—è–¥–∏—Ç", "–ø–æ–∫–∞–∂–∏ –∫–∞–∫ –æ–Ω–∏ –≤—ã–≥–ª—è–¥–µ–ª–∏"]
    message = message.lower()
    return any(keyword in message for keyword in drawing_keywords)

def send_image(update: Update, context: CallbackContext, image_url: str) -> None:
    try:
        response = requests.get(image_url)
        image = BytesIO(response.content)
        image.name = 'image.png'
        update.message.reply_photo(photo=image)
    except Exception as e:
        error_msg = f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {str(e)}"
        logger.error(error_msg)
        update.message.reply_text(error_msg)

# –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è
def log_interaction(user_id, user_username, user_message, gpt_reply):
    try:
        conn = psycopg2.connect(
            dbname=DB_NAME,
            user=DB_USER,
            password=DB_PASSWORD,
            host=DB_HOST,
            port=DB_PORT
        )
        cursor = conn.cursor()
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        cursor.execute('''
        INSERT INTO askgbt_logs (user_id, user_username, user_message, gpt_reply, timestamp)
        VALUES (%s, %s, %s, %s, %s)
        ''', (user_id, user_username, user_message, gpt_reply, timestamp))
        conn.commit()
        cursor.close()
        conn.close()
        # logger.info("–í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ —É—Å–ø–µ—à–Ω–æ –∑–∞–ø–∏—Å–∞–Ω–æ –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø–∏—Å–∏ –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö: {str(e)}")

# –ó–∞–ø—Ä–æ—Å—ã –∫ ChatGPT
def ask_chatgpt(messages) -> str:
    logger.info(f"–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ ChatGPT: {messages}")
    try:
        response = openai.ChatCompletion.create(
            model="gpt-4o-mini",  # –ò–ª–∏ –¥—Ä—É–≥–æ–π –≤—ã–±—Ä–∞–Ω–Ω—ã–π —Ç–æ–±–æ–π –º–æ–¥–µ–ª—å–Ω—ã–π —Ç–∏–ø
            messages=messages,
            max_tokens=100,  # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ–∫–µ–Ω–æ–≤ –¥–ª—è –∫—Ä–∞—Ç–∫–æ—Å—Ç–∏
            temperature=0.5,  # –ù–∏–∑–∫–∞—è —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ –¥–ª—è –∫—Ä–∞—Ç–∫–æ—Å—Ç–∏ –∏ –ø—Ä—è–º–æ—Ç—ã
            n=1,
        )
        answer = response.choices[0].message['content'].strip()
        logger.info(f"–û—Ç–≤–µ—Ç ChatGPT: {answer}")

        clean_answer = answer.replace(')', '').replace('(', '')

        return add_emojis_at_end(clean_answer)
    except Exception as e:
        error_msg = f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞—â–µ–Ω–∏–∏ –∫ ChatGPT: {str(e)}"
        logger.error(error_msg)
        return error_msg

def generate_joke() -> str:
    joke_prompt = [
        {"role": "system", "content": "–¢—ã - –±–æ—Ç, –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–∏–¥—É–º—ã–≤–∞–µ—Ç —Å–º–µ—à–Ω—ã–µ –∞–Ω–µ–∫–¥–æ—Ç—ã. –ü—Ä–∏–¥—É–º–∞–π –∫–æ—Ä–æ—Ç–∫–∏–π –Ω–µ–æ–±–∏–¥–Ω—ã–π –∞–Ω–µ–∫–¥–æ—Ç –ø—Ä–æ —Ñ–µ–º–±–æ—è –∏ –ª–µ–∑–±–∏—è–Ω–∫—É –ù–∏–Ω—É."}
    ]
    return ask_chatgpt(joke_prompt)

def generate_image(prompt: str) -> str:
    logger.info(f"–û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –Ω–∞ —Å–æ–∑–¥–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å –æ–ø–∏—Å–∞–Ω–∏–µ–º: {prompt}")
    try:
        response = openai.Image.create(
            prompt=prompt,
            n=1,
            size="1024x1024"
        )
        image_url = response['data'][0]['url']
        logger.info(f"–ü–æ–ª—É—á–µ–Ω–∞ —Å—Å—ã–ª–∫–∞ –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ: {image_url}")
        return image_url
    except Exception as e:
        error_msg = f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {str(e)}"
        logger.error(error_msg)
        return error_msg

# –§—É–Ω–∫—Ü–∏—è —Å—Ç–∞—Ä—Ç–∞ –±–æ—Ç–∞
def start(update: Update, context: CallbackContext) -> None:
    update.message.reply_text('–ü—Ä–∏–≤–µ—Ç! –Ø - –°–≤–µ–∫–ª–∞–Ω–∞, —Ç–≤–æ—è –≤–∏—Ä—Ç—É–∞–ª—å–Ω–∞—è –ø–æ–¥—Ä—É–≥–∞. –î–∞–≤–∞–π –ø–æ–æ–±—â–∞–µ–º—Å—è! üòä')

def extract_text_from_message(message: Message) -> str:
    if message.text:
        return message.text.strip()
    if message.caption:
        return message.caption.strip()
    return ""

def should_respond(update: Update, context: CallbackContext) -> bool:
    message = update.message

    if not message:
        return False

    bot_username = context.bot.username
    keywords = [ "—Å–≤–µ–∫–ª–∞–Ω–∞", "–ø–æ–º–æ–≥–∏", "–≤–æ–ø—Ä–æ—Å", "–æ—Ç–≤–µ—Ç—å", "–ø–æ—á–µ–º—É"]

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —É–ø–æ–º–∏–Ω–∞–Ω–∏—è –±–æ—Ç–∞
    if message.entities:
        for entity in message.entities:
            if entity.type == 'mention' and message.text[entity.offset:entity.offset + entity.length].lower() == f"@{bot_username}".lower():
                logger.info(f"–ë–æ—Ç —É–ø–æ–º—è–Ω—É—Ç –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏: {message.text}")
                return True

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —É–ø–æ–º—è–Ω—É—Ç—ã –ª–∏ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞
    if any(keyword in message.text.lower() for keyword in keywords):
        logger.info(f"–°–æ–æ–±—â–µ–Ω–∏–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ: {message.text}")
        return True

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç–æ–º –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ –±–æ—Ç–∞
    if message.reply_to_message and message.reply_to_message.from_user.username == bot_username:
        logger.info("–°–æ–æ–±—â–µ–Ω–∏–µ —è–≤–ª—è–µ—Ç—Å—è –æ—Ç–≤–µ—Ç–æ–º –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ –±–æ—Ç–∞")
        return True

    return False

def process_voice_message(voice_message, user_id):
    if voice_message is None:
        logger.error("–ì–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")
        return None

    voice_file_path = f"voice_{user_id}.ogg"
    file = voice_message.get_file()
    file.download(voice_file_path)
    logger.info(f"–°–∫–∞—á–∞–Ω –≥–æ–ª–æ—Å–æ–≤–æ–π —Ñ–∞–π–ª: {voice_file_path}")

    audio = AudioSegment.from_file(voice_file_path, format="ogg")
    wav_file_path = f"voice_{user_id}.wav"
    audio.export(wav_file_path, format="wav")
    logger.info(f"–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω –≤ WAV: {wav_file_path}")

    recognizer = sr.Recognizer()
    with sr.AudioFile(wav_file_path) as source:
        audio_data = recognizer.record(source)
        try:
            user_message = recognizer.recognize_google(audio_data, language="ru-RU")
            logger.info(f"–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ: {user_message}")
            return user_message
        except sr.UnknownValueError:
            logger.error("–ò–∑–≤–∏–Ω–∏—Ç–µ, —è –Ω–µ —Å–º–æ–≥–ª–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ.")
            return None
        except sr.RequestError as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞—â–µ–Ω–∏–∏ –∫ —Å–µ—Ä–≤–∏—Å—É —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ä–µ—á–∏: {str(e)}")
            return None
        finally:
            os.remove(voice_file_path)
            os.remove(wav_file_path)

def process_video_message(video_message, user_id):
    logger.info(f"–ù–∞—á–∞–ª–æ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤–∏–¥–µ–æ —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}")
    video_file_path = f"video_{user_id}.mp4"
    file = video_message.get_file()
    file.download(video_file_path)
    logger.info(f"–í–∏–¥–µ–æ —Ñ–∞–π–ª —Å–∫–∞—á–∞–Ω: {video_file_path}")

    # –ò–∑–≤–ª–µ–∫–∞–µ–º –∞—É–¥–∏–æ –∏–∑ –≤–∏–¥–µ–æ
    audio_file_path = f"audio_{user_id}.wav"
    video = mp.VideoFileClip(video_file_path)
    video.audio.write_audiofile(audio_file_path)
    logger.info(f"–ê—É–¥–∏–æ –∏–∑–≤–ª–µ—á–µ–Ω–æ –∏–∑ –≤–∏–¥–µ–æ –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –∫–∞–∫: {audio_file_path}")

    recognizer = sr.Recognizer()
    with sr.AudioFile(audio_file_path) as source:
        audio_data = recognizer.record(source)
        try:
            user_message = recognizer.recognize_google(audio_data, language="ru-RU")
            logger.info(f"–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ –≤–∏–¥–µ–æ: {user_message}")
            return user_message
        except sr.UnknownValueError:
            logger.error("–ò–∑–≤–∏–Ω–∏—Ç–µ, —è –Ω–µ —Å–º–æ–≥–ª–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –∞—É–¥–∏–æ –∏–∑ –≤–∏–¥–µ–æ.")
            return None
        except sr.RequestError as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞—â–µ–Ω–∏–∏ –∫ —Å–µ—Ä–≤–∏—Å—É —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ä–µ—á–∏: {str(e)}")
            return None
        finally:
            # –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã
            os.remove(video_file_path)
            os.remove(audio_file_path)

def handle_voice(update: Update, context: CallbackContext) -> None:
    if not update.message:
        return

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ –±–æ—Ç—É –æ—Ç–≤–µ—á–∞—Ç—å
    if should_respond(update, context):
        user_id = update.message.from_user.id
        voice_message = update.message.voice  # –ü–æ–ª—É—á–∞–µ–º –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è

        if voice_message:  # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
            user_message = process_voice_message(voice_message, user_id)

            if user_message:
                # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ—Ç–≤–µ—Ç–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ, –µ—Å–ª–∏ –æ–Ω–æ –µ—Å—Ç—å
                if update.message.reply_to_message:
                    if update.message.reply_to_message.voice:
                        # –ï—Å–ª–∏ –æ—Ç–≤–µ—Ç –Ω–∞ –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –µ–≥–æ
                        original_voice_message = update.message.reply_to_message.voice
                        original_text = process_voice_message(original_voice_message, user_id)
                        if original_text:
                            user_message = f"{original_text} {user_message}"

                    elif update.message.reply_to_message.text:
                        # –ï—Å–ª–∏ –æ—Ç–≤–µ—Ç –Ω–∞ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ, –¥–æ–±–∞–≤–ª—è–µ–º –µ–≥–æ –∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–º—É
                        original_text = update.message.reply_to_message.text
                        user_message = f"{original_text} {user_message}"

                # –ò–º–∏—Ç–∞—Ü–∏—è —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è, —á—Ç–æ–±—ã –±–æ—Ç –º–æ–≥ –æ—Ç–≤–µ—Ç–∏—Ç—å –∫–∞–∫ –Ω–∞ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
                update.message.text = user_message
                handle_message(update, context, is_voice=True)
            else:
                update.message.reply_text("–ò–∑–≤–∏–Ω–∏—Ç–µ, —è –Ω–µ —Å–º–æ–≥–ª–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –≤–∞—à–µ –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ.")
        else:
            logger.error("–ì–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")

def handle_video(update: Update, context: CallbackContext) -> None:
    if not update.message:
        return

    if should_respond(update, context):
        user_id = update.message.from_user.id
        logger.info(f"–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–∏–¥–µ–æ —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}")
        user_message = process_video_message(update.message.video, user_id)

        if user_message:
            logger.info(f"–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–µ –≤–∏–¥–µ–æ —Å–æ–æ–±—â–µ–Ω–∏–µ: {user_message}")
            if update.message.reply_to_message:
                update.message.text = user_message
                handle_message(update, context, is_video=True)
            else:
                update.message.reply_text(user_message)

# –§—É–Ω–∫—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π
def handle_message(update: Update, context: CallbackContext, is_voice=False, is_video=False) -> None:
    if not update.message:
        return

    user_id = update.message.from_user.id
    user_username = update.message.from_user.username  # –ü–æ–ª—É—á–∞–µ–º –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    user_message = extract_text_from_message(update.message)

    if is_voice:
        user_message = process_voice_message(update.message.reply_to_message.voice, user_id)
        if not user_message:
            return

    if is_video:
        user_message = process_video_message(update.message.reply_to_message.video, user_id)
        if not user_message:
            return

    if "–≥–µ–∏" in user_message.lower():
        joke = generate_joke()
        update.message.reply_text(joke)
        return

    if is_drawing_request(user_message):
        prompt = user_message
        image_url = generate_image(prompt)
        send_image(update, context, image_url)
        return

    if not is_voice and not is_video and not should_respond(update, context):
        return

    if update.message.reply_to_message and not is_voice and not is_video:
        original_message = extract_text_from_message(update.message.reply_to_message)
        if not original_message and update.message.reply_to_message.voice:
            original_message = process_voice_message(update.message.reply_to_message.voice, user_id)
        if not original_message and update.message.reply_to_message.video:
            original_message = process_video_message(update.message.reply_to_message.video, user_id)
        if not original_message:
            return
        user_message = f"{original_message} {user_message}"

    conversation_context[user_id].append({"role": "user", "content": user_message})

    messages = initial_instructions + conversation_context[user_id]

    reply = ask_chatgpt(messages)

    conversation_context[user_id].append({"role": "assistant", "content": reply})

    update.message.reply_text(reply, parse_mode=ParseMode.MARKDOWN)

    # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å —É—á—ë—Ç–æ–º –∏–º–µ–Ω–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    log_interaction(user_id, user_username, user_message, reply)

# –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞
def main():
    updater = Updater(TELEGRAM_TOKEN)
    dispatcher = updater.dispatcher

    init_db()

    dispatcher.add_handler(CommandHandler("start", start))
    dispatcher.add_handler(CommandHandler("describe_me", describe_user))
    dispatcher.add_handler(MessageHandler(Filters.text & ~Filters.command, handle_message))
    dispatcher.add_handler(MessageHandler(Filters.voice, handle_voice))
    dispatcher.add_handler(MessageHandler(Filters.video, handle_video))

    updater.start_polling()
    updater.idle()

if __name__ == '__main__':
    main()
